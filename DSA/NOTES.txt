 -----------------------------------------------------------------------------------------------------------------------------------------------
 DATE: 21/08/2024
 -----------------------------------------------------------------------------------------------------------------------------------------------

 DATA STRUCTURE:
    -Data Struture is about how data can be store and use in different Strutures.

ALGORITHEM:
    -Algorithm is a step-by-step procedure for solving a problem.

ASYMPTOTIC NOTATIOIN:
    -Asymptotic notation is used to describe the time and space complexity of an algorithm.

    -There are mainly three type of notation:
        1. Big O notation: It is used to describe the upper bound or wrost case of an algorithm's time or
           space complexity.

        2. Big Ω notation: It is used to describe the lower bound of an algorithm's time or
           space complexity.

        3. Big Θ notation: It is used to describe the exact time or space complexity of an algorithm.


    -There are mainly two types of complexity for any program:
        1. Time complexity: It is the amount of time an algorithm takes to complete as a function of
           the size of the input.
        
        2. Space complexity: It is the amount of memory an algorithm takes to complete as a function of
           the size of the input.
    
        
                                       COMPLEXITY OF PROGRAM

      NOTATIOIN           |        NAME             |              DESCRIPTION
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(1)                | Constant                | The time taken by the algorithm is constant and does
                          |                         | not depend on the size of the input.
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(log n)            | Logarithmic             | The time taken by the algorithm is proportional
                          |                         | to the logarithm of the size of the input.
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(n)                | Linear                  | The time taken by the algorithm is proportional
                          |                         | to the size of the input.
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(n log n)          | Linearithmic            | The time taken by the algorithm is
                          |                         | proportional to the product of the size of the input and its logarithm
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(n^2)              | Quadratic               | The time taken by the algorithm is proportional
                          |                         | to the square of the size of the input.
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(2^n)              | Exponential             | The time taken by the algorithm is proportional
                          |                         | to 2 raised to the power of the size of the input.
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      O(n!)               | Factorial               | The time taken by the algorithm is proportional
                          |                         | to the factorial of the size of the input.
      --------------------|-------------------------|-----------------------------------------------------------------------------------
      

 -----------------------------------------------------------------------------------------------------------------------------------------------
 DATE: 22/08/2024
 -----------------------------------------------------------------------------------------------------------------------------------------------

LINKEDLIST:
   -A linked list is a linear data structure where each element is a separate object, known as a node.
   -Linklist nodes are randomly stored in the memory.
   -link field of Linklist is of self reerential type.

   -Each node contains two items:
      1. The data, and
      2. A reference (or link) to the next node in the sequence.

      -------    -------    -------    ---------
      |10|1k|--->|20|2k|--->|30|3k|--->|40|NULL|
      -------    -------    -------    ---------

   LinkedList over Array:
   
      -Dynamic memory allocation: Linked list can grow or shrink as needed.
      -Insertion and deletion: Linked list allows for efficient insertion and deletion of nodes at any position.
      -Memory usage: Linked list uses more memory than arrays because each node has a reference to the
       next node.
      -Random access: Linked list does not support random access, you have to traverse the list from
       the beginning to access a specific node.
      -Cache performance: Linked list can have poor cache performance because the memory is not contiguous.
      -Traversal: Linked list can be traversed in both forward and backward directions.
      -Search: Linked list can be searched in both forward and backward directions.
      -Sorting: Linked list can be sorted in both forward and backward directions.
      -Reversing: Linked list can be reversed in both forward and backward directions.
   

 -----------------------------------------------------------------------------------------------------------------------------------------------
 DATE: 23/08/2024
 -----------------------------------------------------------------------------------------------------------------------------------------------


DOUBLY LINKEDLIST:
   -A doubly linked list is a type of linked list in which each node has two pointers,
      one pointing to the next node and the other pointing to the previous node.
   -This allows for efficient insertion and deletion of nodes at any position in the list.
   -It also allows for traversal in both forward and backward directions.
   -It is used in many applications such as database systems, file systems, and memory management.
   -The node containing NULL at there "next" field that is called Tail of list.
   -The node containing NULL at there "previous" field that is called Head of list.



CIRCULAR LINKEDLIST:
   -A circular linked list is a type of linked list in which the last node points back to
   the first node, forming a circle.
   -It is used in many applications such as circular buffers, circular queues, and
   circular stacks.

   
VECTOR: 
   -A vector is a dynamic array that can grow or shrink as needed.
   -It is used to store a collection of elements of the same data type.
   -It is implemented as a contiguous block of memory.
   -Vector is define inside <vector> header file.
   -Vector is a part of C++ Standard Template Library (STL).
   -Vector is based on last in first out (LIFO) algorithm.

   Pre-defind methods of vector:
      -push_back(): Adds an element to the end of the vector.
      -pop_back(): Removes the last element from the vector.
      -insert(): Inserts an element at a specified position in the vector.
      -erase(): Removes an element at a specified position in the vector.
      -size(): Returns the number of elements in the vector.
      -capacity(): Returns the maximum number of elements the vector can hold.
      -empty(): Checks if the vector is empty.
      -at(): Returns the element at a specified position in the vector.
      -front(): Returns the first element in the vector.
      -back(): Returns the last element in the vector.
      -begin(): Returns an iterator(reference) pointing to the first element in the vector.
      -end(): Returns an iterator pointing(reference) to the end of the vector.
      -clear(): Removes all elements from the vector.
      -resize(): Changes the size of the vector to a specified value.
      -reserve(): Changes the capacity of the vector to a specified value.
      -swap(): interchange all elements of two vectors.
   
      -Vector is class template inside memory, therefore sizeof() operator return the size of class vector.

PAIRS:
   -A pair is a class template that represents a collection of two values.
   -It is used to store two values of different data types.
   
   Syntax:
      pair <data_type, data_type> p;

   -we can create array of pairs to store some number of data inside it.


 -----------------------------------------------------------------------------------------------------------------------------------------------
 DATE: 27/08/2024
 -----------------------------------------------------------------------------------------------------------------------------------------------

STACK:
   -A stack is a linear data structure that follows the LIFO (Last In First Out).
   -It is a type of abstract data type (ADT) that uses the principle of last in
    first out to access the elements.
   -Stack is a collection of elements that are added and removed from the top of the stack.
   -Stack is a part of C++ Standard Template Library (STL).
   -Stack is implemented as a class template inside <stack> header file.
   -Stack is a dynamic data structure that can grow or shrink as needed.
   -Stack is a non-associative data structure, meaning that the order of elements is
    not preserved.
    
   Main operations:
      -push(): Adds an element to the top of the stack.
      -pop(): Removes an element from the top of the stack.
      -top(): Returns the element at the top of the stack.
      -size(): Return size of stack.
      -empty(): Checks if the stack is empty.




   Example:
      -Recursion
      -Function calls
      -Undo and redo operations
      -Evaluation of postfix expressions
      -Evaluation of infix expressions
      -Evaluation of prefix expressions


POLISH NOTATIOIN:
   -Polish notation is a notation in which operators are written before their operands.
   -This notation was introduced by the polish mathematician Lukasiewicz.
   -Polish notation is also known as prefix notation.
   -Polish notation is used to evaluate expressions in a left-to-right order.

   There are three types of polish notation:
      1. Prefix notation: In this notation, operators are written before their operands.
         Example:
          ab
          +ab*C

      2. Infix notation: In this notation, operators are written between their operands.
         Example:
          a + b   
          a + b * c

      3. Postfix notation: In this notation, operators are written after their operands.
         Example:
          ab+
          abc*-
          abc*/


      operators       |        Precedence         |         Associativity
      ----------------|---------------------------|-------------------------
      (), [], {}      |        4                  |        Left to Right
      ^               |        3                  |        Left to Right
      * , /           |        2                  |        Left to Right
      + , -           |        1                  |        Left to Right

   
   Operands:
      -Operands are the values that are used in an expression.
      -Operands can be numbers, variables, or expressions.
      Example:
         (3, 4, 5)
         (x, y, z)
   Operators:
      -Operators are the symbols that are used to perform operations on operands.
      -Operators can be unary or binary.
      Example:
         (+, -, *, /, %, etc)
   
      

 -----------------------------------------------------------------------------------------------------------------------------------------------
 DATE: 29/08/2024
 -----------------------------------------------------------------------------------------------------------------------------------------------

Rule to convert Infix to Postfix:
   1. No two operators with same precedence are stay together in stack.
   2. Operators with lower precedence can not stay after the operator with higher precedence.

   Example:
      + * this is valid
      * + this is not valid
      * ^ this is valid

QUEUE:
   -A queue is a linear data structure that follows the FIFO (First-In-First-Out) principle.
   -Elements are added to the end of the queue and removed from the front of the queue.
   -Queue is used to implement the postfix notation of an expression.
   Example:
      -Process scheduling
      -Job scheduling
      -Network routing


   Operations in Queue:

      Enqueue:
         -Add an element to the end of the queue.
         -This is perform by push().
      
      Dequeue:
         -Remove an element from the front of the queue.
         -This is perform by pop().

      front() or peek():
         -Return the element at the front of the queue without removing it.
      
      back():
         -Return the element at the end of the queue without removing it.
      
      
 -----------------------------------------------------------------------------------------------------------------------------------------------
 DATE: 02/09/2024
 -----------------------------------------------------------------------------------------------------------------------------------------------

DOUBLE ENDEND QUEUE:
   -A double-ended queue is a queue that allows elements to be added or removed from both ends
   -It is also known as a deque
   -It is implemented using a doubly linked list
   -It supports the following operations:
      -bool isFull();
      -bool isEmpty();
      -void enqueueFront();
      -void enqueueRear();
      -void dequeueFront();
      -void dequeueRear();
      -int getFront();
      -int getRear();



CIRCULAR QUEUE:
   -A circular queue is a type of queue where the last element is connected to the first element.
   -It is also known as a ring buffer.
   -It is used when the size of the queue is fixed and we want to reuse the space when
    the queue is empty.

   Enqueue: r = (r + 1) % SIZE
   Dequeue: f = (f + 1) % SIZE
      where r is the rear index and f is the front index.
   

RECURSION:
   -Recursion is a programming technique where a function calls itself repeatedly until it reaches a base case.


